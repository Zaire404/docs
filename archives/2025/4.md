---
title: go Context详解
number: '#4'
link: 'https://github.com/Zaire404/docs/issues/4'
created_at: '2025-02-14 21:50:58'
updated_at: '2025-02-15 21:07:46'
labels: []
---
go 1.23.4
## 接口
### Context
### cancelCtx
```go
type cancelCtx struct {
    Context
    mu       sync.Mutex            // protects following fields
    done     atomic.Value          // of chan struct{}, created lazily, closed by first cancel call
    children map[canceler]struct{} // set to nil by the first cancel call
    err      error                 // set to non-nil by the first cancel call
    cause    error                 // set to non-nil by the first cancel call
}
```
`cancelCtx`嵌入了一个`Context`,继承了`Context`的所有特性，所以`cancelCtx`可以被看成一个`Context`
`done`采用懒加载的方式创建
```go
func (c *cancelCtx) Done() <-chan struct{} {
	d := c.done.Load()
	if d != nil {
		return d.(chan struct{})
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	d = c.done.Load()
	if d == nil {
		d = make(chan struct{})
		c.done.Store(d)
	}
	return d.(chan struct{})
}
```
再是cancel
```go
// closedchan is a reusable closed channel.
var closedchan = make(chan struct{})

// cancel closes c.done, cancels each of c's children, and, if
// removeFromParent is true, removes c from its parent's children.
// cancel sets c.cause to cause if this is the first time c is canceled.
func (c *cancelCtx) cancel(removeFromParent bool, err, cause error) {
	if err == nil {
		panic("context: internal error: missing cancel error")
	}
	if cause == nil {
		cause = err
	}
	c.mu.Lock()
	if c.err != nil {
		c.mu.Unlock()
		return // already canceled
	}
	c.err = err
	c.cause = cause
	d, _ := c.done.Load().(chan struct{})
	if d == nil {
		c.done.Store(closedchan)
	} else {
		close(d)
	}
	for child := range c.children {
		// NOTE: acquiring the child's lock while holding parent's lock.
		child.cancel(false, err, cause)
	}
	c.children = nil
	c.mu.Unlock()

	if removeFromParent {
		removeChild(c.Context, c)
	}
}
```
用`c.done.Store(closedchan)`关闭chan，递归取消所有子节点。
可以看到在取消子节点`child.cancel(false,err,cause)`中传入了false，因为后面执行了`c.child = nil`，没必要在子节点取消时多做一步。
